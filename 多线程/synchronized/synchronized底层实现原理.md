### 说一下synchronized底层实现原理?

synchronized的底层是使用操作系统的mutex lock实现的。

synchronized用的锁是存在Java对象头里的;

JVM基于 **进入和退出Moniter对象** 来实现方法同步和代码块同步; 
- 任何对象都有一个moniter对象与之相连, 当且一个moniter被持有后,它将处于锁定状态

代码块同步: 使用moniterenter和moniterexit指令实现的:
1. enter
- moniterenter指令是在编译后插入到同步代码块的开始位置;
- 执行moniterenter指令时, 首先要去尝试获取对象的锁, 如果这个对象没被锁定,或者当前线程已经拥有了那个对象的锁,把锁的计数器加1;
2. exit
- moniterexit指令是插入到方法结束处和异常处. 
- 执行moniterexit指令时,要将锁的计数器减1;
3. 当计数器被减到0时，锁就释放了。
4. 如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。
- 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。
- synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；




***

### Java1.6之后锁有哪些类型?
- 锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。
- Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：
- 偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。


### 什么是重量级锁?
- Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。
- 而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。
- 因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。


### 什么是偏向锁?
> - 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。
**偏向锁是为了在只有一个线程执行同步块时提高性能。**
1. 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
2. 引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，
- 因为轻量级锁的获取及释放依赖多次CAS原子指令，
- 而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。

### 什么是轻量级锁?
**轻量级锁是为了在线程近乎交替执行同步块时提高性能。**


### 偏向锁、轻量级锁、重量级锁之间是如何转换的?






> 参考:
> https://blog.csdn.net/javazejian/article/details/72828483
> https://www.cnblogs.com/aspirant/p/11470858.html
> https://zhuanlan.zhihu.com/p/29866981
> https://www.tutorialfor.com/blog-238296.htm




































