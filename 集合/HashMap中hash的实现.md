### 你知道HashMap中hash的实现吗？为什么要这样实现？

> 参考资料: https://www.zhihu.com/question/20733617

```
static final int hash(Object key) {
    int h;
    //扰动函数: Hash值=key的hashCode值 异或 自身无符号右移16位 
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

//将扰动后得到的hash值与数组长度做运算再得到数组的下标;
bucketIndex = indexFor(hash, table.length);
static int indexFor(int h, int length) {
    //把散列值和数组长度做一个"与"操作，
    return h & (length-1);
}
```

hashMap中的hash实质上是做了一个扰动函数, 
- 因为key对应的hashCode的值取值范围广,无法直接存储, 
> key.hashCode()，返回的是int型散列值,8个16进制数, 共32位, 
> 2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间
- 因此我们将它扰动后得到的hash值拿去与数组长度做运算再得到数组的下标;


### h & (length-1) 把散列值和数组长度做一个"与"操作，
- ** （数组长度-1） **  正好相当于一个“低位掩码”
- ** & **  “与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问
> 以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111
> - 和某散列值做“与”操作如下，结果就是截取了最低的四位值。

```
    0100101 11000100 00100101
 &  00000000 00000000 00001111
 _____________________________
    00000000 00000000 00000101    //高位全部归零，只保留末四位

```

- 但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。


### 扰动函数 (h = key.hashCode()) ^ (h >>> 16) 
本身hashCode()值为8个16进制数，共32位. 右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。


***



### 什么是>>>?
无符号右移运算符：>>>
> 参考: https://zhuanlan.zhihu.com/p/30108890
1. value >>> num     --   num 指定要移位值value 移动的位数。
3. 无符号右移运算符>>的运算规则也很简单，丢弃右边指定位数，左边补上0。
3. 无符号右移运算符>>>和右移运算符>>是一样的，只不过右移时左边是补上符号位，而无符号右移运算符是补上0，也就是说，对于正数移位来说等同于：>>，负数通过此移位运算符能移位成正数。(符号位: 0表示正数1表示负数)

### 什么是^?
按位异或运算符^
- 参加运算的两个数据，按二进制位进行“异或”运算。
- 运算规则：0^0=0， 1^0=1， 0^1=1， 1^1=0 //如果两个相应位相同，则结果为0，否则为1。


### 什么是&?
按位与运算符（&）
- 参加运算的两个数据，按二进制位进行“与”运算。
- 运算规则：0&0=0;   0&1=0;    1&0=0;     1&1=1;



