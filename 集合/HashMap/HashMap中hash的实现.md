
### 你知道HashMap中hash的实现吗？为什么要这样实现？

一. 因为我们存储键值对到HashMap数组里时,其实是做了两件事.
1. 第一步:将key的hashCode值做一个扰动处理, 作为它的hash值
2. 第二步: 因为这个hash值的取值范围还很广,因此实际存储的数组下标是将这个hash值与数组长度运算h & (length-1)后得到的,这样会缩小范围.

二. 详细来说
1. **第一步混合高低位信息得到hash值**我们将key的HashCode值与它自身做一个无符号右移16位后,再取两者的异或结果. 因为这个key的hashCode值是32位字节,就是8个16进制数, 将它右移16位,取异或, 会混合它的高位和低位信息.
2. **之所以需要混合高低位信息,是因为第二步操作只保留了hash值的低位信息,不先混合就容易碰撞**
 之所以需要混合高低位信息, 是因为第二步,我们是将hash值与数组长度做一个与运算,(数组长度-1),实际运算会发现它保留的是这个hash值的低位信息. 如果没有上一步的扰动运算的话, 这样会很容易发生碰撞.


```
static final int hash(Object key) {
    int h;
    //扰动函数: Hash值=key的hashCode值 异或 自身无符号右移16位 
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

//将扰动后得到的hash值与数组长度做运算再得到数组的下标;
bucketIndex = indexFor(hash, table.length);
static int indexFor(int h, int length) {
    //把散列值和数组长度做一个"与"操作，
    return h & (length-1);
}
```


> 参考资料: https://www.zhihu.com/question/20733617


***


>1. hashMap中的hash实质上是做了一个扰动函数, 
>2. 因为key对应的hashCode的值取值范围广,无法直接存储, 
>> key.hashCode()，返回的是int型散列值,8个16进制数, 共32位, 
>> 2进制32位带符号的int表值范围从-2147483648到2147483648。前后加起来大概40亿的映射空间
>3, 因此我们将它扰动后得到的hash值拿去与数组长度做运算再得到数组的下标;


### h & (length-1) 把散列值和数组长度做一个"与"操作，
- ** （数组长度-1） **  正好相当于一个“低位掩码”
- ** & **  “与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问
> 以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111
> - 和某散列值做“与”操作如下，结果就是截取了最低的四位值。

```
    0100101 11000100 00100101
 &  00000000 00000000 00001111
 _____________________________
    00000000 00000000 00000101    //高位全部归零，只保留末四位

```

- 但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。


### 扰动函数 (h = key.hashCode()) ^ (h >>> 16) 
本身hashCode()值为8个16进制数，共32位. 右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。


***



> 参考资料: https://www.zhihu.com/question/20733617



